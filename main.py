from Helper import add_columns, relevant_data_finder, find_dictionary_by_name, write_message
import csv 
import pandas as pd
import tkinter as tk
import asyncio
import subprocess
import os

raw_data_file = 'Sample Data Raw.csv'
updated_data_file = 'sample.csv'
user_info_file = 'UserInfo.txt'

new_columns = ["Industries", "How do you know them", "Role(s)", "Commonalities"]

info_about_user = open(user_info_file).read()

# Extracts raw data from csv file
with open(raw_data_file, mode='r', newline='') as file:
    reader = csv.DictReader(file)
    raw_data = list(reader)  # raw_data is a list of dictionaries 

# updated_data is a list of dictionaries containing the updated data
updated_data = asyncio.run(add_columns(raw_data, new_columns, info_about_user))


def button_click(row):
    global no_names_clicked_yet
    text = ''
    for key in row:
        text += f'{key}: {row[key]}\n\n'
    response_label.config(text=text)  

    if no_names_clicked_yet:
        more_thoughts_label = tk.Label(root, text="(Optional) Any more thoughts I should note before writing this LinkedIn message?")
        more_thoughts_label.pack(pady=0)

        more_thoughts_entry = tk.Entry(root)
        more_thoughts_entry.pack(pady=0)
        
        write_message_button = tk.Button(root, text="Write LinkedIn message (takes up to 15s)")
        write_message_button.pack(pady=20)

        no_names_clicked_yet = False

    write_message_button.config(command=lambda: write_message_button_action(row, more_thoughts_entry.get()))

def write_message_button_action(row, more_thoughts):
    print(row.values(), more_thoughts)
    
    result_label = tk.Label(root, text="Writing LinkedIn message... (takes up to 15 seconds)", wraplength=1500)
    result_label.pack(pady=20)

    name = row['Name']
    comments = row.get('Comments', '') 
    reason = row['Reason']

    message = write_message(name, comments, reason, more_thoughts, prompt, info_about_user)

    result_label.config(text=message)

# Adds updated data to a new csv file
fieldnames = updated_data[0].keys()  
with open(updated_data_file, mode='w', newline='') as file:
    writer = csv.DictWriter(file, fieldnames=fieldnames)
    writer.writeheader()
    writer.writerows(updated_data)

# Read the prompt from a file
prompt = open('prompt.txt', 'r').read().strip()

# Run the external script to process the data (if necessary)
# subprocess.run("pip freeze | grep aijson", shell=True, capture_output=True, text=True)
# subprocess.run(['python', 'pipeline.py', prompt])
# will save pre-processed dataframe as OUTPUT.csv

# Read the OUTPUT.csv generated by pipeline.py into a DataFrame
relevant_data_df = pd.read_csv('OUTPUT.csv')

# Convert the DataFrame to a list of dictionaries
relevant_data = relevant_data_df.to_dict(orient='records')

root = tk.Tk()
root.title("Simple GUI")
root.geometry("3000x1500")

no_names_clicked_yet = True

opening_label = tk.Label(root, text=f"These are the most relevant results for your request: {prompt}", wraplength=1500)
opening_label.pack(pady=20)

# Creating buttons and corresponding labels for the top 3 relevant data entries
for row in relevant_data[:3]:
    button = tk.Button(root, text=row['Name'], command=lambda r=row: button_click(r))
    button.pack(pady=10)
    
    reason_label = tk.Label(root, text=f"Reason: {row['Reason']}", wraplength=1500)
    reason_label.pack(pady=10)

response_label = tk.Label(root, text="", wraplength=1500)
response_label.pack(pady=20)

root.mainloop()